//////////////////////////////////////////////////////////////////////////
// Computing Ramification Polynomials and Polygons and Residal Polynomials
//
// see Guardia, Jones, Keating, Pauli, and Roe, Distinguished Defining Polynomials for Extensions of p-Adic Fields, 2025
//
// By Sebastian Pauli, December 2025
//

"Loading rampoly.m";

declare verbose Rampoly, 6;

////////////////////////////////////////////
// Ramification Polygons and Polynomials

intrinsic RamificationPoly(phi::RngUPolElt,nu::RngUPolElt,alpha::RngPadElt:Skip:=true) -> .
{Ramification polygon and polynomial phi(alpha+nu(alpha)x) of a nu-Oystein polynomial phi, where alpha is a root of phi.}
//"RamificationPoly(phi",IsEisenstein(phi),",",nu,",alpha)";
        L:=Parent(alpha);
        Lx<x> := PolynomialRing(L);
        e := Degree(phi) div Degree(nu);
//"nu",Parent(nu);
//"alpha",Parent(alpha);
        nualpha := Evaluate(nu,alpha);
        rho:=Evaluate(Lx!phi,nualpha*x + alpha) div nualpha^e;

//n := Degree(phi);
//rhofl := [0:i in [0..n-1]  cat [1];  
/*
  K := CoefficientRing(phi);
  pi := UniformizingElement(K);
  eta := nualpha^e div pi;
  etainv := 1/eta;
  for i in [0..n-1] do
    rhoi := 0;
    for j in [j..n] do
	rhoi := rhoi + (Coefficient(phi,i) div pi)*Binomial
    end for;	
  end for;	
*/
        ramification_polygon := NewtonPolygon([<-i,Valuation(Coefficient(rho,i))>:i in [1..Degree(rho)]]);
        return ramification_polygon,rho;
end intrinsic;

intrinsic RamificationPoly(phi::RngUPolElt) -> .
{Ramification polygon and polynomial of the extension defined by phi.}
//"RamificationPoly(phi",IsEisenstein(phi),")";
        if IsEisenstein(phi) then
          Kx<x> := Parent(phi);
          K := CoefficientRing(phi);
          L := TotallyRamifiedExtension(K,phi);
          return RamificationPoly(phi,x,L.1);
        else
          phi, nu, alpha := OysteinPoly(phi);
          return RamificationPoly(phi,nu,alpha);
        end if;
end intrinsic;

intrinsic HasseHerbrand(R::NwtnPgon,m) -> .
{e*Phi(m), where Phi is the Hasse Herbrand function of the ramification polygon R}
  h := Minimum([r[2]-r[1]*m:r in LowerVertices(R)]);
  return h;
end intrinsic

intrinsic HasseHerbrand(phi::RngUPolElt,m) -> .
{e*Phi(m), where Phi is the Hasse Herbrand function of the ramification polygon R}
  R,rho := RamificationPoly(phi);
  h := Minimum([r[2]-r[1]*m:r in LowerVertices(R)]);
  return h;
end intrinsic


/////////////////////////////////////////////////////////////////////////
//Residual Polynomials

function ramification_poly_raw(phi,alpha)
	// rho:=phi(alpha+x) and the Newton polygon of rho
        L:=Parent(alpha);
        Lx<x> := PolynomialRing(L);
        rho:=Evaluate(Lx!phi,x + alpha);
        ramification_polygon := NewtonPolygon(rho);
        return ramification_polygon,rho;
end function;

intrinsic AdditiveResidualPoly(phi::RngUPolElt,nu::RngUPolElt,alpha::RngPadElt,m::RngIntElt) -> .
{
The residual polynomial of the segment of the ramfication polygon of phi of slope m and e times the
Hasse Herbrand function of phi at m.  alpha is a root of phi and nu(alpha) a uniformizing 
element in the extension definied by phi with deg(phi)=e*deg(nu).}
          rp, rho := ramification_poly_raw(phi,alpha);
          LX<X> := Parent(rho);
          L := CoefficientRing(LX);
          nualpha := Evaluate(LX!nu,alpha);
          RL, LtoRL := ResidueClassField(L);
          RLz<z> := PolynomialRing(RL);
          rhom := Evaluate(rho,nualpha^(m+1)*X);
          cont := Minimum([Valuation(a) : a in Coefficients(rhom)]);
          rdpc := rhom div nualpha^cont;
          Sm := &+[z^i*LtoRL(Coefficient(rdpc,i)): i in [0..Degree(rdpc)]];
          return Sm, cont;
end intrinsic;

intrinsic ResidualPolys(phi::RngUPolElt,nu::RngUPolElt,alpha::RngPadElt) -> .
{
The residual polynomials of the segments of the ramfication polygon of phi.
alpha is a root of phi and nu(alpha) a uniformizing element in the extensions generated by alpha.}
//"ResidualPolys: nu=",nu;
          rp, rho := ramification_poly_raw(phi,alpha);
          LX<X> := Parent(rho);
          L := CoefficientRing(LX);
          nualpha := Evaluate(nu,alpha);
          RL, LtoRL := ResidueClassField(L);
          RLz<z> := PolynomialRing(RL);

          slopes := Reverse([-m:m in LowerSlopes(rp)]);
          vertices := Reverse(LowerVertices(rp));
          A := [];

          for l in [1..#slopes] do
            m := slopes[l];
            i := vertices[l][1];
            vri := vertices[l][2];
            j := Integers()!vertices[l+1][1];
            vrj := Integers()!vertices[l+1][2];
            t := Numerator(m);
            d := Denominator(m);
//"ResidualPolys: rho =",rho;
            a := &+[LtoRL(Coefficient(rho,(k*d+j)) div nualpha^(vrj-k*t))*z^k: k in [0..Integers()!((i-j)/d)]];
            Append(~A,a);
          end for;
          return A;

end intrinsic;


intrinsic ResidualPolys(phi:absolute:=false) -> .
{
The residual polynomials of the segments of the ramfication polygon of phi.
}

  if IsEisenstein(phi) then
    nu := Parent(phi)![0,1];
    K<alpha> := TotallyRamifiedExtension(CoefficientRing(phi),phi);
    return ResidualPolys(phi,nu,alpha);
  elif absolute then
    psi, nu, alpha := OysteinPoly(phi); 
    return ResidualPolys(psi,nu,alpha);
  else  
    _ , nu, alpha := OysteinPoly(phi); 
    pi := Evaluate(nu,alpha);
    psi := CharacteristicPolynomial(pi);
    K := CoefficientRing(psi);
    psi := ChangePrecision(psi,Precision(K));
    L := TotallyRamifiedExtension(K,psi);
    X := Polynomial(K,[0,1]);
    return ResidualPolys(psi,X,L.1);
  end if;
end intrinsic;

intrinsic ResidualPolyClasses(phi::RngUPolElt:with_trans:=false,conjugates:=false) -> .
{The residual polynomial classes of an Eisenstein polynomial phi}

      if not IsEisenstein(phi) then
        conjugates := true;
        _ , nu, alpha := OysteinPoly(phi); 
        pi := Evaluate(nu,alpha);
        phi := CharacteristicPolynomial(pi);
      end if;

      Kx<x> := Parent(phi);
      K := CoefficientRing(phi);
      RK, KtoRK := ResidueClassField(K);
      pi := UniformizingElement(K);
      n := Degree(phi);
      
      function residual_polynomial_classes_sub(phi,with_trans)
        invA := {};
        for delta in RK do
          if delta ne 0 then
            deltaK := K!delta;
            phidelta := Kx!([Coefficient(phi,i)*deltaK^(n-i) : i in [0..n]]);
            if with_trans then
              Include(~invA,<ResidualPolys(phidelta),phidelta,delta>);
            else
              Include(~invA,ResidualPolys(phidelta));
            end if;
          end if;
        end for;
        return invA;
      end function;

      if not conjugates then
        return residual_polynomial_classes_sub(phi,with_trans);
      else
        invA := {};
        gaut, maut := AutomorphismGroup(K);
        aut := [ maut(tau) : tau in gaut ];
        for tau in aut do
          vprintf Monge,1: "ResidualPolyClasses: %o |-> %o\n",KtoRK(K.1),KtoRK(tau(K.1));
          tauphi := Kx![ tau(c): c in Coefficients(phi)]; 
          invA join:= residual_polynomial_classes_sub(tauphi,with_trans);
        end for;
        return invA;
      end if;
end intrinsic;

